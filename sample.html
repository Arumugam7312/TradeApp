<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p>
    <h1> Usage in Vue Component</h1>

    ----------------------------------------------------------------------------------------
    <script>
import { registerUser, fetchBankDetails } from '@/services/eventService';

export default {
  methods: {
    async submitForm() {
      if (this.$refs.form.validate()) {
        this.loading = true;
        
        const result = await registerUser({
          personal: this.personal,
          bank: this.bank,
          options: this.options,
          mcxFiles: this.mcxFiles
        });
        
        this.loading = false;
        
        if (result.success) {
          this.$notify({
            type: 'success',
            title: 'Success',
            text: result.message
          });
        } else {
          this.$notify({
            type: 'error',
            title: 'Error',
            text: result.message
          });
        }
      }
    },
    
    async fetchBankDetails() {
      if (this.bank.ifsc && this.bank.ifsc.length === 11) {
        const result = await fetchBankDetails(this.bank.ifsc);
        
        if (result.success) {
          this.bank.bankName = result.data.bankName;
          this.bank.branchName = result.data.branchName;
          this.bank.bankAddress = result.data.bankAddress;
          this.bank.micr = result.data.micr;
        } else {
          this.$notify({
            type: 'error',
            title: 'Bank Details',
            text: result.message
          });
        }
      }
    }
  }
};
</script>
  </p>






  <p>
    <h1>go Main func</h1>

------------------------------------------------------------------------


    package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"yourproject/database"
	"time"
)

type User struct {
	FatherName  string `json:"fatherName"`
	MotherName  string `json:"motherName"`
	Country     string `json:"country"`
	State       string `json:"state"`
	City        string `json:"city"`
	Pincode     string `json:"pincode"`
	Address     string `json:"address"`
	IncomeRange string `json:"incomeRange"`
	AccountNo   string `json:"accountNumber"`
	BankName    string `json:"bankName"`
	BranchName  string `json:"branchName"`
	IFSC        string `json:"ifsc"`
	BankAddress string `json:"bankAddress"`
	MICR        string `json:"micr"`
	NSC         bool   `json:"nsc"`
	BSC         bool   `json:"bsc"`
	MCX         bool   `json:"mcx"`
	MCXFiles    string `json:"mcxFiles"`
}

type Response struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
	ID      int64  `json:"id,omitempty"`
}

func main() {
	// Initialize database
	err := database.InitDB("root", "password", "localhost", "3306", "form_app")
	if err != nil {
		log.Fatal(err)
	}
	
	err = database.CreateTables()
	if err != nil {
		log.Fatal(err)
	}

	// Register handlers
	http.HandleFunc("/api/register", registerHandler)
	http.HandleFunc("/api/bank/", bankHandler)

	// CORS middleware
	http.Handle("/", corsMiddleware(http.DefaultServeMux))

	log.Println("Server running on port 8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		
		if r.Method == "OPTIONS" {
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	if r.Method != "POST" {
		jsonResponse(w, false, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var user User
	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		jsonResponse(w, false, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Insert user with 'inprogress' status
	query := `INSERT INTO users (
		father_name, mother_name, country, state, city, pincode, address,
		income_range, account_number, bank_name, branch_name, ifsc,
		bank_address, micr, nsc, bsc, mcx, mcx_files, status
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'inprogress')`

	result, err := database.DB.Exec(query,
		user.FatherName, user.MotherName, user.Country, user.State, user.City,
		user.Pincode, user.Address, user.IncomeRange, user.AccountNo,
		user.BankName, user.BranchName, user.IFSC, user.BankAddress,
		user.MICR, user.NSC, user.BSC, user.MCX, user.MCXFiles)

	if err != nil {
		jsonResponse(w, false, "Failed to register user: "+err.Error(), http.StatusInternalServerError)
		return
	}

	id, _ := result.LastInsertId()
	jsonResponse(w, true, "Registered successfully", http.StatusOK, id)
}

func bankHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	if r.Method != "GET" {
		jsonResponse(w, false, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	ifsc := r.URL.Path[len("/api/bank/"):]
	if len(ifsc) != 11 {
		jsonResponse(w, false, "Invalid IFSC code", http.StatusBadRequest)
		return
	}

	// Call Razorpay IFSC API
	resp, err := http.Get("https://ifsc.razorpay.com/" + ifsc)
	if err != nil {
		jsonResponse(w, false, "Failed to fetch bank details", http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		jsonResponse(w, false, "Bank details not found", http.StatusNotFound)
		return
	}

	body, _ := ioutil.ReadAll(resp.Body)
	w.Write(body)
}

func jsonResponse(w http.ResponseWriter, success bool, message string, statusCode int, id ...int64) {
	response := Response{
		Success: success,
		Message: message,
	}
	if len(id) > 0 {
		response.ID = id[0]
	}
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(response)
}
  </p>









  <p>

    <h1>Complete Vue.js Frontend</h1>

<!-- ------------------------------------------------------------ -->



    <template>
  <v-container>
    <v-card class="pa-6">
      <v-card-title class="headline">Registration Form</v-card-title>
      
      <v-form ref="form" v-model="valid" lazy-validation @submit.prevent="submitForm">
        <!-- Personal Information Section -->
        <v-card-text>
          <v-row>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="personal.fatherName"
                label="Father's Name"
                :rules="nameRules"
                required
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="personal.motherName"
                label="Mother's Name"
                :rules="nameRules"
                required
              ></v-text-field>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="12" md="4">
              <v-text-field
                v-model="personal.country"
                label="Country"
                :rules="[v => !!v || 'Country is required']"
                required
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="4">
              <v-text-field
                v-model="personal.state"
                label="State"
                :rules="[v => !!v || 'State is required']"
                required
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="4">
              <v-text-field
                v-model="personal.city"
                label="City"
                :rules="[v => !!v || 'City is required']"
                required
              ></v-text-field>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="personal.pincode"
                label="Pincode"
                :rules="pincodeRules"
                required
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="personal.address"
                label="Address"
                :rules="[v => !!v || 'Address is required']"
                required
              ></v-text-field>
            </v-col>
          </v-row>
        </v-card-text>

        <!-- Bank Information Section -->
        <v-card-title class="headline">Bank Information</v-card-title>
        <v-card-text>
          <v-row>
            <v-col cols="12" md="6">
              <v-select
                v-model="bank.incomeRange"
                :items="incomeRanges"
                label="Income Range"
                :rules="[v => !!v || 'Income range is required']"
                required
              ></v-select>
            </v-col>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="bank.accountNumber"
                label="Account Number"
                :rules="accountNumberRules"
                required
              ></v-text-field>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="bank.ifsc"
                label="IFSC Code"
                :rules="ifscRules"
                required
                @blur="fetchBankDetails"
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="bank.micr"
                label="MICR Code"
                :rules="micrRules"
                required
              ></v-text-field>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="bank.bankName"
                label="Bank Name"
                :rules="[v => !!v || 'Bank name is required']"
                required
              ></v-text-field>
            </v-col>
            <v-col cols="12" md="6">
              <v-text-field
                v-model="bank.branchName"
                label="Branch Name"
                :rules="[v => !!v || 'Branch name is required']"
                required
              ></v-text-field>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="12">
              <v-textarea
                v-model="bank.bankAddress"
                label="Bank Address"
                :rules="[v => !!v || 'Bank address is required']"
                required
              ></v-textarea>
            </v-col>
          </v-row>
        </v-card-text>

        <!-- Options Section -->
        <v-card-title class="headline">Additional Options</v-card-title>
        <v-card-text>
          <v-checkbox
            v-model="options.nsc"
            label="NSC"
          ></v-checkbox>
          <v-checkbox
            v-model="options.bsc"
            label="BSC"
          ></v-checkbox>
          <v-checkbox
            v-model="options.mcx"
            label="MCX"
            @change="showMCXFileUpload = options.mcx"
          ></v-checkbox>

          <v-file-input
            v-if="showMCXFileUpload"
            v-model="mcxFiles"
            label="Upload MCX Documents"
            multiple
            :rules="options.mcx ? [v => v.length > 0 || 'At least one file is required'] : []"
          ></v-file-input>
        </v-card-text>

        <!-- Submit Button -->
        <v-card-actions>
          <v-btn
            color="primary"
            type="submit"
            :disabled="!valid"
            :loading="loading"
          >
            Submit
          </v-btn>
          <v-btn
            color="secondary"
            @click="resetForm"
          >
            Reset
          </v-btn>
        </v-card-actions>
      </v-form>
    </v-card>

    <v-snackbar v-model="snackbar.show" :color="snackbar.color">
      {{ snackbar.message }}
      <template v-slot:action="{ attrs }">
        <v-btn text v-bind="attrs" @click="snackbar.show = false">Close</v-btn>
      </template>
    </v-snackbar>
  </v-container>
</template>

<script>
import { registerUser, fetchBankDetails } from '@/services/eventService';

export default {
  data() {
    return {
      valid: true,
      loading: false,
      personal: {
        fatherName: '',
        motherName: '',
        country: '',
        state: '',
        city: '',
        pincode: '',
        address: ''
      },
      bank: {
        incomeRange: null,
        accountNumber: '',
        bankName: '',
        branchName: '',
        ifsc: '',
        bankAddress: '',
        micr: ''
      },
      options: {
        nsc: false,
        bsc: false,
        mcx: false
      },
      showMCXFileUpload: false,
      mcxFiles: [],
      incomeRanges: [
        'Below 2.5 Lakh',
        '2.5 Lakh - 5 Lakh',
        '5 Lakh - 10 Lakh',
        'Above 10 Lakh'
      ],
      snackbar: {
        show: false,
        message: '',
        color: 'success'
      },
      nameRules: [
        v => !!v || 'Name is required',
        v => (v && v.length >= 3) || 'Name must be at least 3 characters'
      ],
      pincodeRules: [
        v => !!v || 'Pincode is required',
        v => /^\d{6}$/.test(v) || 'Pincode must be 6 digits'
      ],
      accountNumberRules: [
        v => !!v || 'Account number is required',
        v => /^\d{9,18}$/.test(v) || 'Account number must be 9-18 digits'
      ],
      ifscRules: [
        v => !!v || 'IFSC code is required',
        v => /^[A-Z]{4}0[A-Z0-9]{6}$/.test(v) || 'Invalid IFSC code format'
      ],
      micrRules: [
        v => !!v || 'MICR code is required',
        v => /^\d{9}$/.test(v) || 'MICR code must be 9 digits'
      ]
    };
  },
  methods: {
    async submitForm() {
      if (this.$refs.form.validate()) {
        this.loading = true;
        
        try {
          const result = await registerUser({
            personal: this.personal,
            bank: this.bank,
            options: this.options,
            mcxFiles: this.mcxFiles
          });

          if (result.success) {
            this.showSnackbar('Registered successfully! Redirecting to login...', 'success');
            setTimeout(() => {
              this.$router.push('/login');
            }, 2000);
          } else {
            this.showSnackbar(result.message, 'error');
          }
        } catch (error) {
          this.showSnackbar(error.message || 'Registration failed', 'error');
        } finally {
          this.loading = false;
        }
      }
    },
    async fetchBankDetails() {
      if (this.bank.ifsc && this.bank.ifsc.length === 11) {
        const result = await fetchBankDetails(this.bank.ifsc);
        
        if (result.success) {
          this.bank.bankName = result.data.bankName;
          this.bank.branchName = result.data.branchName;
          this.bank.bankAddress = result.data.bankAddress;
          this.bank.micr = result.data.micr;
        } else {
          this.showSnackbar(result.message, 'error');
        }
      }
    },
    resetForm() {
      this.$refs.form.reset();
      this.options.mcx = false;
      this.showMCXFileUpload = false;
      this.mcxFiles = [];
    },
    showSnackbar(message, color) {
      this.snackbar.message = message;
      this.snackbar.color = color;
      this.snackbar.show = true;
    }
  }
};
</script>

<style scoped>
.v-card {
  margin-bottom: 24px;
}
</style>
  </p>



  <p>
    <h1>main.go</h1>







    package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

type User struct {
	FatherName  string `json:"fatherName"`
	MotherName  string `json:"motherName"`
	Country     string `json:"country"`
	State       string `json:"state"`
	City        string `json:"city"`
	Pincode     string `json:"pincode"`
	Address     string `json:"address"`
	IncomeRange string `json:"incomeRange"`
	AccountNo   string `json:"accountNumber"`
	BankName    string `json:"bankName"`
	BranchName  string `json:"branchName"`
	IFSC        string `json:"ifsc"`
	BankAddress string `json:"bankAddress"`
	MICR        string `json:"micr"`
	NSC         bool   `json:"nsc"`
	BSC         bool   `json:"bsc"`
	MCX         bool   `json:"mcx"`
	MCXFiles    string `json:"mcxFiles"`
}

type Response struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func main() {
	// Initialize database connection
	var err error
	db, err = sql.Open("mysql", "username:password@tcp(localhost:3306)/your_database?parseTime=true")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Verify connection
	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}

	// Register handlers
	http.HandleFunc("/api/register", registerHandler)
	http.HandleFunc("/api/bank/", bankHandler)

	// CORS middleware
	http.Handle("/", corsMiddleware(http.DefaultServeMux))

	log.Println("Server running on port 8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		
		if r.Method == "OPTIONS" {
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	if r.Method != "POST" {
		jsonResponse(w, false, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var user User
	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		jsonResponse(w, false, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Insert into existing table
	query := `INSERT INTO users (
		father_name, mother_name, country, state, city, pincode, address,
		income_range, account_number, bank_name, branch_name, ifsc,
		bank_address, micr, nsc, bsc, mcx, mcx_files, status
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'inprogress')`

	_, err = db.Exec(query,
		user.FatherName, user.MotherName, user.Country, user.State, user.City,
		user.Pincode, user.Address, user.IncomeRange, user.AccountNo,
		user.BankName, user.BranchName, user.IFSC, user.BankAddress,
		user.MICR, user.NSC, user.BSC, user.MCX, user.MCXFiles)

	if err != nil {
		jsonResponse(w, false, "Failed to register user: "+err.Error(), http.StatusInternalServerError)
		return
	}

	jsonResponse(w, true, "Registered successfully", http.StatusOK)
}

func bankHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	if r.Method != "GET" {
		jsonResponse(w, false, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	ifsc := r.URL.Path[len("/api/bank/"):]
	if len(ifsc) != 11 {
		jsonResponse(w, false, "Invalid IFSC code", http.StatusBadRequest)
		return
	}

	// Call Razorpay IFSC API
	resp, err := http.Get("https://ifsc.razorpay.com/" + ifsc)
	if err != nil {
		jsonResponse(w, false, "Failed to fetch bank details", http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		jsonResponse(w, false, "Bank details not found", http.StatusNotFound)
		return
	}

	// Forward the response
	w.WriteHeader(resp.StatusCode)
	resp.Write(w)
}

func jsonResponse(w http.ResponseWriter, success bool, message string, statusCode int) {
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(Response{
		Success: success,
		Message: message,
	})
}
  </p>





  <p>
    <h1>src/services/eventService.js</h1>


    import axios from 'axios';
import router from '../router';

const api = axios.create({
  baseURL: 'http://localhost:8080/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Response interceptor
api.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response) {
      // Handle specific status codes
      const message = error.response.data?.message || 
                     error.response.statusText || 
                     'An error occurred';
      return Promise.reject(message);
    }
    return Promise.reject(error);
  }
);

export const registerUser = async (formData) => {
  try {
    const payload = {
      fatherName: formData.personal.fatherName,
      motherName: formData.personal.motherName,
      country: formData.personal.country,
      state: formData.personal.state,
      city: formData.personal.city,
      pincode: formData.personal.pincode,
      address: formData.personal.address,
      incomeRange: formData.bank.incomeRange,
      accountNumber: formData.bank.accountNumber,
      bankName: formData.bank.bankName,
      branchName: formData.bank.branchName,
      ifsc: formData.bank.ifsc,
      bankAddress: formData.bank.bankAddress,
      micr: formData.bank.micr,
      nsc: formData.options.nsc,
      bsc: formData.options.bsc,
      mcx: formData.options.mcx,
      mcxFiles: JSON.stringify(formData.mcxFiles.map(file => file.name))
    };

    const response = await api.post('/register', payload);
    return {
      success: true,
      message: response.message || 'Registration successful'
    };
  } catch (error) {
    return {
      success: false,
      message: error
    };
  }
};

export const fetchBankDetails = async (ifsc) => {
  try {
    const response = await api.get(`/bank/${ifsc}`);
    return {
      success: true,
      data: {
        bankName: response.BANK,
        branchName: response.BRANCH,
        bankAddress: response.ADDRESS,
        micr: response.MICR
      }
    };
  } catch (error) {
    return {
      success: false,
      message: error
    };
  }
};
  </p>
</body>
</html>